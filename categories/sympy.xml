<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Björn I. Dahlgren's personal page (Posts about SymPy)</title><link>http://bjodah.github.io/blog/</link><description></description><atom:link rel="self" type="application/rss+xml" href="http://bjodah.github.io/blog/categories/sympy.xml"></atom:link><language>en</language><lastBuildDate>Mon, 26 Jun 2017 20:29:46 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Status update week 4 GSoC</title><link>http://bjodah.github.io/blog/posts/gsoc-week4.html</link><dc:creator>Björn Dahlgren</dc:creator><description>&lt;div&gt;&lt;div class="section" id="continued-work-on-tutorial-material"&gt;
&lt;h2&gt;Continued work on tutorial material&lt;/h2&gt;
&lt;p&gt;During the past week I got &lt;a class="reference external" href="https://mybinder.org"&gt;binder&lt;/a&gt; to work with
our tutorial material. Using &lt;tt class="docutils literal"&gt;environment.yml&lt;/tt&gt; did require that we had
a conda package available. So I set up our instance of &lt;a class="reference external" href="https://drone.io"&gt;Drone IO&lt;/a&gt; to push to the &lt;tt class="docutils literal"&gt;sympy&lt;/tt&gt; conda channel. The new
base dockerimage used in the beta version of binder (v2) does not
contain gcc by default. This prompted me to add gcc to our
&lt;tt class="docutils literal"&gt;environment.yml&lt;/tt&gt;, unfortunately this breaks the build process:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Attempting to roll back.
LinkError: post-link script failed for package defaults::gcc-4.8.5-7
running your command again with `-v` will provide additional information
location of failed script: /opt/conda/bin/.gcc-post-link.sh
==&amp;gt; script messages &amp;lt;==
&amp;lt;None&amp;gt;
&lt;/pre&gt;
&lt;p&gt;I've reached out on their gitter channel, we'll see if anyone knows
what's up. If we cannot work around this we will have two options:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Accept that the binder version cannot compile any generated code&lt;/li&gt;
&lt;li&gt;Try to use binder with a Dockerimage based on the one used for CI
tests (with the difference that it will include a prebuilt conda
environment from &lt;tt class="docutils literal"&gt;environment.yml&lt;/tt&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I hope that the second approach should work unless we hit a image size
limitation (and perhaps we need a special base image, I haven't looked
into those details yet).&lt;/p&gt;
&lt;p&gt;Jason has been producing some really high quality tutorial notebooks
and left lots of constructive feedback on my initial work. Based on
his feedback I've started reworking the code-generation examples not
to use classes as extensively. I've also added some introductory
notebooks: numerical integration of ODEs in general &amp;amp; intro to SymPy's
cryptically named &lt;tt class="docutils literal"&gt;lambdify&lt;/tt&gt; (the latter notebook is still to be
merged into master).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="work-on-sympy-for-version-1-1"&gt;
&lt;h2&gt;Work on SymPy for version 1.1&lt;/h2&gt;
&lt;p&gt;After last weeks mentor meeting we decided that we would try to
&lt;a class="reference external" href="https://github.com/sympy/sympy/pull/12805"&gt;revert&lt;/a&gt; a change to
&lt;tt class="docutils literal"&gt;sympy.cse&lt;/tt&gt; (a function which performs common subexpression
elimination). I did spend some time profiling the new implementation.
However, I was not able to find any obvious bottle-necks, and given
that it is not the main scope of my project I did not pursue this any
further at the moment.&lt;/p&gt;
&lt;p&gt;I also &lt;a class="reference external" href="https://github.com/sympy/sympy/pull/12808"&gt;just started&lt;/a&gt;
looking at introducing a Python code printer. There is a
&lt;tt class="docutils literal"&gt;PythonPrinter&lt;/tt&gt; in SymPy right now, although it assumes that
&lt;tt class="docutils literal"&gt;SymPy&lt;/tt&gt; is available. The plan right now is to rename to old
printer to &lt;tt class="docutils literal"&gt;SymPyCodePrinter&lt;/tt&gt; and have the new printer primarily print
expressions, which is what the &lt;tt class="docutils literal"&gt;CodePrinter&lt;/tt&gt; class does best, even
though it can be "coerced" into emitting statements.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="plans-for-the-upcoming-week"&gt;
&lt;h2&gt;Plans for the upcoming week&lt;/h2&gt;
&lt;p&gt;As the conference approaches the work intensifies both with respect to
finishing up the tutorial material and fixing blocking issues for a
SymPy 1.1 release. Working on the tutorial material helps finding
things to improve code-generation wise (just today I opened a &lt;a class="reference external" href="https://github.com/sympy/sympy/issues/12810"&gt;minor
issue&lt;/a&gt; just to realize
that my &lt;a class="reference external" href="https://github.com/sympy/sympy/pull/12693"&gt;"work-in-progress" pull-request&lt;/a&gt; from an earlier week
(which I intend to get back working on next week too) actually fixes
said issue.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>Python</category><category>SymPy</category><guid>http://bjodah.github.io/blog/posts/gsoc-week4.html</guid><pubDate>Mon, 26 Jun 2017 19:39:00 GMT</pubDate></item><item><title>Status update week 3 GSoC</title><link>http://bjodah.github.io/blog/posts/gsoc-week3.html</link><dc:creator>Björn Dahlgren</dc:creator><description>&lt;div&gt;&lt;div class="section" id="fast-callbacks-from-sympy-using-symengine"&gt;
&lt;h2&gt;Fast callbacks from SymPy using SymEngine&lt;/h2&gt;
&lt;p&gt;My main focus the past week has been to get &lt;tt class="docutils literal"&gt;Lambdify&lt;/tt&gt; in SymEngine
to work with multiple output parameters. Last year Isuru Fernando lead
the &lt;a class="reference external" href="https://github.com/symengine/symengine/pull/1094"&gt;development&lt;/a&gt; to support jit-compiled callbacks using LLVM in SymEngine.
I started work on leveraging this in the Python wrappers of SymEngine
but my work stalled due to time constraints.&lt;/p&gt;
&lt;p&gt;But since it is very much related to code generation in SymPy I did
put it into my time-line (later in the summer) in my GSoC
application. But with the upcoming SciPy conference, and the fact that
it would make a nice addition to our tutorial, I have put in &lt;a class="reference external" href="https://github.com/symengine/symengine.py/pull/112"&gt;work&lt;/a&gt; to
get this done earlier than first planned.&lt;/p&gt;
&lt;p&gt;Another thing on my to-do-list from last week was to get &lt;tt class="docutils literal"&gt;numba&lt;/tt&gt; working
with &lt;tt class="docutils literal"&gt;lambdify&lt;/tt&gt;. But for this to work we need to wait for a new upstream
release of &lt;tt class="docutils literal"&gt;numba&lt;/tt&gt; (which they are hoping to release before the SciPy
&lt;a class="reference external" href="https://scipy2017.scipy.org/ehome/220975/493418/"&gt;conference&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="status-of-codegen-tutorial-material"&gt;
&lt;h2&gt;Status of codegen-tutorial material&lt;/h2&gt;
&lt;p&gt;I have not added any new tutorial material this week, but have been
working on making all notebooks work under all targeted operating
systems. However, every change to the notebooks have to be checked
on all operating systems using both Python 2 and Python 3. This
becomes tedious very quickly so I decided to enable continuous
integration on our &lt;a class="reference external" href="https://github.com/sympy/scipy-2017-codegen-tutorial"&gt;repository&lt;/a&gt;. I followed conda-forges approach: Travis CI
for OS X, CircleCI for Linux and AppVeyor for Windows (and a private
CI server for another Linux setup). And last night
I &lt;em&gt;finally&lt;/em&gt; got green light on all 4 of our CI services.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="plans-for-the-upcoming-week"&gt;
&lt;h2&gt;Plans for the upcoming week&lt;/h2&gt;
&lt;p&gt;We have had a performance &lt;a class="reference external" href="https://github.com/sympy/sympy/issues/12411"&gt;regression&lt;/a&gt; in &lt;tt class="docutils literal"&gt;sympy.cse&lt;/tt&gt; which has bit me
multiple times this week. I managed to &lt;a class="reference external" href="https://github.com/sympy/sympy_benchmarks/pull/38"&gt;craft&lt;/a&gt; a small test case
indicating that the algorithmic complexity of the new function is
considerably worse than before (effectively making it useless for many
applications). In my weekly mentor-meeting (with Aaron) we discussed
possibly reverting that &lt;a class="reference external" href="https://github.com/sympy/sympy/pull/11232"&gt;change&lt;/a&gt;. I will first try to see if I can
identify easy-to-fix bottlenecks by profiling the code. But the
risk is that it is too much work to be done before the upcoming
new release of SymPy, and then we will simply revert for now (choosing
speed over extensiveness of the sub-expression elimination).&lt;/p&gt;
&lt;p&gt;I still need to test the notebooks using not only &lt;tt class="docutils literal"&gt;msvc&lt;/tt&gt; under Windows
(which is currently used in the AppVeyor tests), but also &lt;tt class="docutils literal"&gt;mingw&lt;/tt&gt;. I did
manage to get it working locally but there is still some effort left
in order to make this work on AppVeyor. It's extra tricky since there
is a &lt;a class="reference external" href="https://bugs.python.org/issue21821"&gt;bug&lt;/a&gt; in &lt;tt class="docutils literal"&gt;distutils&lt;/tt&gt; in Python 3 which causes the detection of mingw
to fail. So we need to either:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Patch &lt;tt class="docutils literal"&gt;cygwincompiler.py&lt;/tt&gt; in &lt;tt class="docutils literal"&gt;distutils&lt;/tt&gt; (which I believe we can do
if we create a conda package for our tutorial material).&lt;/li&gt;
&lt;li&gt;...or use something else than &lt;tt class="docutils literal"&gt;pyximport&lt;/tt&gt; (I'm hesitant to do this
before the conference).&lt;/li&gt;
&lt;li&gt;...or provide a gcc executable (not a &lt;tt class="docutils literal"&gt;.bat&lt;/tt&gt; file) that simply
spawns &lt;tt class="docutils literal"&gt;gcc.bat&lt;/tt&gt; (but that executable would need to be compiled
during build of our conda package).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Based on my work on making the CI services work, we will need to
provide test scripts for the participants to run. We need to provide
the organizers with these scripts by June 27th so this needs to be
decided upon during next week. I am leaning towards providing an
&lt;tt class="docutils literal"&gt;environment.yml&lt;/tt&gt; file together with a simple instruction of
activating said environment, e.g.:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ conda env create -f environment.yml
$ source activate codegen17
$ python -c "import scipy2017codegen as cg; cg.test()"
&lt;/pre&gt;
&lt;p&gt;This could even be tested on our CI services.&lt;/p&gt;
&lt;p&gt;I also intend to add a (perhaps final) tutorial notebook for chemical
kinetics where we also consider diffusion. We will solve the PDE using
the method of lines. The addition of a spatial dimension in this way
is simple in principle, things do tend to become tricky when handling
boundary conditions though. I will try to use the simplest possible
treatment in order to avoid taking focus from what we are teaching
(code-generation).&lt;/p&gt;
&lt;p&gt;It is also my hope that this combined diffusion-reaction model is a
good candidate for &lt;tt class="docutils literal"&gt;ufuncify&lt;/tt&gt; from
&lt;tt class="docutils literal"&gt;sympy.utilities.autowrap&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>Python</category><category>SymPy</category><guid>http://bjodah.github.io/blog/posts/gsoc-week3.html</guid><pubDate>Mon, 19 Jun 2017 21:15:00 GMT</pubDate></item><item><title>Status update week 2 GSoC</title><link>http://bjodah.github.io/blog/posts/gsoc-week2.html</link><dc:creator>Björn Dahlgren</dc:creator><description>&lt;div&gt;&lt;p&gt;I have spent the second week of Google Summer of Code on essentially two things:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Continued work on type awareness in the code printers (&lt;tt class="docutils literal"&gt;CCodePrinter&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;FCodePrinter&lt;/tt&gt;). The work is ongoing in &lt;a class="reference external" href="https://github.com/sympy/sympy/pull/12693"&gt;gh-12693&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Writing tutorial &lt;a class="reference external" href="https://github.com/sympy/scipy-2017-codegen-tutorial"&gt;code&lt;/a&gt; on code-generation in the form of jupyter notebooks for the
upcoming SciPy 2017 &lt;a class="reference external" href="https://scipy2017.scipy.org/ehome/220975/493418/"&gt;conference&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="precision-aware-code-printers"&gt;
&lt;h2&gt;Precision aware code printers&lt;/h2&gt;
&lt;p&gt;After my weekly mentor meeting, we decided to take another approach to
how we are going to represent &lt;tt class="docutils literal"&gt;Variable&lt;/tt&gt; instances in the
&lt;tt class="docutils literal"&gt;.codegen.ast&lt;/tt&gt; module. Previously I had proposed to use quite a
number of arguments (stored in &lt;tt class="docutils literal"&gt;.args&lt;/tt&gt; since it inherits
&lt;tt class="docutils literal"&gt;Basic&lt;/tt&gt;). Aaron suggested we might want to represent that underlying
information differently. After some discussion we came to the
conclusion that we could introduce a &lt;tt class="docutils literal"&gt;Attribute&lt;/tt&gt; class (inhereting
from &lt;tt class="docutils literal"&gt;Symbol&lt;/tt&gt;) to describe things such as value const-ness, and
pointer const-ness (those two are available as &lt;tt class="docutils literal"&gt;value_const&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;pointer_const&lt;/tt&gt;). Attributes will be stored in a &lt;tt class="docutils literal"&gt;FiniteSet&lt;/tt&gt;
(essentially SymPy version of &lt;tt class="docutils literal"&gt;set&lt;/tt&gt;) and the instances we provide as
"pre-made" in the &lt;tt class="docutils literal"&gt;.codegen.ast&lt;/tt&gt; module will be supported by the
printers by default. Here is some example code showing what the
current proposed API looks like (for C99):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; u = symbols('u', real=True)
&amp;gt;&amp;gt;&amp;gt; ptr = Pointer.deduced(u, {pointer_const, restrict})
&amp;gt;&amp;gt;&amp;gt; ccode(Declaration(ptr))
'double * const restrict u;'
&lt;/pre&gt;
&lt;p&gt;and for Fortran:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; vx = Variable(Symbol('x'), {value_const}, float32)
&amp;gt;&amp;gt;&amp;gt; fcode(Declaration(vx, 42))
'real(4), parameter :: x = 42'
&lt;/pre&gt;
&lt;p&gt;The C code printer can now also print code using different math functions depending
on the targeted precision (functions guaranteed to be present in the C99 stanard):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; ccode(x**3.7, standard='c99', precision=float32)
'powf(x, 3.7F)'
&amp;gt;&amp;gt;&amp;gt; ccode(exp(x/2), standard='c99', precision=float80)
'expl((1.0L/2.0L)*x)'
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="tutorial-material-for-code-generation"&gt;
&lt;h2&gt;Tutorial material for code generation&lt;/h2&gt;
&lt;p&gt;Aaron, Jason and I have been discussing what examples to use for the
tutorial on code generation with SymPy. Right now we are aiming to use
quite a few examples from chemistry actually, and more specifically
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Chemical_kinetics"&gt;chemical kinetics&lt;/a&gt;. This is the
precise application which got me started using SymPy for
code-generation, so it lies close to my heart (I do extensive modeling
of chemical kinetics in my PhD studies).&lt;/p&gt;
&lt;p&gt;Working on the tutorial material has already been really helpful for
getting insight in development needs for the exisiting classes and
functions used for code-generation. I was hoping to use &lt;tt class="docutils literal"&gt;autowrap&lt;/tt&gt;
from the &lt;tt class="docutils literal"&gt;.utilities&lt;/tt&gt; module. Unfortunately I found that it was not
flexible enough to be useful for integration of systems of ODEs (where
we need to evaluate a vector-valued function taking a vector as
input). I did attempt to subclass the &lt;tt class="docutils literal"&gt;CodeWrapper&lt;/tt&gt; class to allow
me to do this. But personally I found those classes to be quite hard to
extend (much unlike the printers which I've often found to be
intuitive).&lt;/p&gt;
&lt;p&gt;My current plan for the chemical kinetics case is to first solve it
using &lt;tt class="docutils literal"&gt;sympy.lambdify&lt;/tt&gt;.  That allows for quick prototyping, and
unless one has very high demands with respect to performance, it is
usually good enough.&lt;/p&gt;
&lt;p&gt;The next step is to generate a native callback (it was here I was
hoping to use &lt;tt class="docutils literal"&gt;autowrap&lt;/tt&gt; with the Cython backend). The current
approach is to write the expressions as Cython code using a template.
Cython conveniently follows Python syntax, and hence the string
printer can be used for the code generation. Doing this speeds up the
integration considerably. At this point the bottleneck is going back and
forth through the Python layer.&lt;/p&gt;
&lt;p&gt;So in order to speed up the integration further, we need to bypass
Python during integration (and let the solver call the user
provided callbacks without going through the interpreter). I did
this by providing a C-code template which relies on &lt;tt class="docutils literal"&gt;CVode&lt;/tt&gt; from the
&lt;a class="reference external" href="https://computation.llnl.gov/projects/sundials"&gt;Sundials&lt;/a&gt; suite of
non-linear solvers. It is a well established solver and is already
available for Linux, Mac &amp;amp; Windows under conda from the
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;conda-forge&lt;/span&gt;&lt;/tt&gt; channel. I then provide a thin Cython wrapper, calling
into the C-function, which:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;sets up the CVode solver&lt;/li&gt;
&lt;li&gt;runs the integration&lt;/li&gt;
&lt;li&gt;records some statistics&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Using native code does come at a cost. One of the strengths of Python
is that it is cross-platform. It (usually) does not matter if your
Python application runs on Linux, OSX or Windows (or any other
supported operating system). However, since we are doing
code-generation, we are relying on compilers provided by the
respective platform. Since we want to support both Python 2 &amp;amp; Python 3
on said three platforms, there are quite a few combinations to cover.
That meant quite a few surprises (I now know for example that MS
Visual C++ 2008 does not support C99), but thanks to the kind &lt;a class="reference external" href="https://github.com/sympy/scipy-2017-codegen-tutorial/issues/2#issuecomment-307538308"&gt;help&lt;/a&gt; of
&lt;a class="reference external" href="https://github.com/isuruf"&gt;Isuru Fernando&lt;/a&gt; I think I will manage to
have all platform/version combinations working during next week.&lt;/p&gt;
&lt;p&gt;Also planned for next week:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use &lt;tt class="docutils literal"&gt;numba&lt;/tt&gt; together with &lt;tt class="docutils literal"&gt;lambdify&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;tt class="docutils literal"&gt;Lambdify&lt;/tt&gt; from &lt;a class="reference external" href="https://github.com/symengine"&gt;SymEngine&lt;/a&gt;
(preferably with the LLVM backend).&lt;/li&gt;
&lt;li&gt;Make the notebooks more tutorial like (right now they are more of a
show-case).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and of course: continued work on the code printers. That's all for now
feel free to get in touch with any feedback or questions.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>Python</category><category>SymPy</category><guid>http://bjodah.github.io/blog/posts/gsoc-week2.html</guid><pubDate>Sun, 11 Jun 2017 21:37:00 GMT</pubDate></item><item><title>A summer of code and mathematics</title><link>http://bjodah.github.io/blog/posts/gsoc-week1.html</link><dc:creator>Björn Dahlgren</dc:creator><description>&lt;div&gt;&lt;p&gt;Google are generously funding work on selected &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Open-source_software"&gt;open source&lt;/a&gt; projects each
year through the &lt;a class="reference external" href="https://summerofcode.withgoogle.com/"&gt;Google Summer of Code&lt;/a&gt; project. The project allows
under- and post-graduate students around the world to apply to
mentoring organizations for a scholarship to work on a project during
the summer. This spring I made the leap, I wrote a &lt;a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2017-Application-Bj%C3%B6rn-Dahlgren:-Improved-code-generation-facilities"&gt;proposal&lt;/a&gt; which
got accepted, and I am now working full time for the duration of this
summer on one of these projects. In this blog post I'll give some
background and tell you about the first project week.&lt;/p&gt;
&lt;div class="section" id="background"&gt;
&lt;h2&gt;Background&lt;/h2&gt;
&lt;p&gt;Since a few years I've been contributing code to the open-source project
&lt;a class="reference external" href="http://www.sympy.org"&gt;SymPy&lt;/a&gt;. SymPy is a so-called "computer algebra system",
which lets you manipulate mathematical expressions symbolically. I've used this
software package extensively in my own doctoral studies and it has been really useful.&lt;/p&gt;
&lt;p&gt;My research involves formulating mathematical models to: rationalize experimental observations,
fit parameters or aid in design of experiments. Traditionally one sits down and derive equations,
often using pen &amp;amp; paper, then one writes computer code which implements said model, and finally
one writes a paper with the same formulas as LaTeX code (or something similar).
Note how this procedure involves writing the same equations essentially three times,
during derivation, coding and finally the article.&lt;/p&gt;
&lt;p&gt;By using SymPy I can, from a single source:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Do the derivations (fewer hard-to-find mistakes)&lt;/li&gt;
&lt;li&gt;Generate the numerical code (a blazing fast computer program)&lt;/li&gt;
&lt;li&gt;Output LaTeX formatted equations (pretty formulas for the report)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A very attractive side-effect of this is that one truly get reproducible research
(reproducibility is one of the pillars in science). Every step of the process is
self-documented, and because SymPy is free software: &lt;em&gt;anyone&lt;/em&gt; can redo them. I
can't stress enough how big this truly is. It is also the main
motivation why I haven't used proprietary software in place of SymPy,
even though that software may be considerably more feature complete
than SymPy, any code I wrote for it would be inaccessible to people
without a license (possibly even including myself if I leave academia).&lt;/p&gt;
&lt;p&gt;For this work-flow to work in practice the capabilities of the computer algebra system
need to be quite extensive, and it is here my current project with SymPy comes in.
I have had several ideas on how to improve capability number two
listed above: generating the numerical code, and now I get the chance
to realize some of them and work with the community to improve SymPy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="first-week"&gt;
&lt;h2&gt;First week&lt;/h2&gt;
&lt;p&gt;The majority of the first week has been spent on introducing type-awareness into
the code-printers. SymPy has printer-classes which specialize printing of e.g.
strings, C code, Fortran code etc. Up to now there has been no way to indicate
what precision the generated code should be for. The default floating point type
in python is for example "double precision" (i.e. 64-bit binary IEEE 754 floating
point). This is also the default precision targeted by the code
printers.&lt;/p&gt;
&lt;p&gt;However, there are occasions where one want to use another
precision. For example, consumer class graphics cards which are
ubiquitous often have excellent single precision performance, but are
intentionally capped with respect to double precision arithmetic (due
to marketing reasons). At other times, one want just a bit of extra
precision and extended precision (80-bit floating point, usually the
data type of C's &lt;tt class="docutils literal"&gt;long double&lt;/tt&gt;) is just what's needed to compute
some values with the required precision. In C, the &lt;a class="reference external" href="http://en.cppreference.com/w/c/numeric/math"&gt;corresponding math functions&lt;/a&gt; are standardized since
C99.&lt;/p&gt;
&lt;p&gt;I have started the work to enable the code printers to print this in a
&lt;a class="reference external" href="https://github.com/sympy/sympy/pull/12693"&gt;pull-request&lt;/a&gt; to the
SymPy source repository. I have also started experimenting with a
class representing arrays. Arrays&lt;/p&gt;
&lt;p&gt;The first weekly meeting with &lt;a class="reference external" href="http://asmeurer.com"&gt;Aaron Meurer&lt;/a&gt; went well and we also briefly
discussed how to reach out to the SymPy community for wishes on what
code-generation functions to provide, I've set up a wiki-page for it
under the SymPy projects wiki:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/sympy/sympy/wiki/codegen-gsoc17"&gt;https://github.com/sympy/sympy/wiki/codegen-gsoc17&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I'll be sending out an email to the &lt;a class="reference external" href="https://groups.google.com/forum/#!forum/sympy"&gt;mailing list for SymPy&lt;/a&gt; asking for feedback.&lt;/p&gt;
&lt;p&gt;We also discussed the upcoming SciPy 2017 conference where Aaron
Meurer and &lt;a class="reference external" href="http://www.moorepants.info/"&gt;Jason Moore&lt;/a&gt; will be giving
a tutorial on code-generation with SymPy. They've asked me to join
forces with them and I've happily accepted that offer and am looking
forward to working on the tutorial material and teaching fellow
developers and researchers in the scientific python community about
how to leverage SymPy for code generation.&lt;/p&gt;
&lt;p&gt;Next blog post will most likely be a bit more technical, but I thought
it was important to give some background on what motivates this effort
and what the goal is.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>Python</category><category>SymPy</category><guid>http://bjodah.github.io/blog/posts/gsoc-week1.html</guid><pubDate>Sat, 03 Jun 2017 13:10:00 GMT</pubDate></item></channel></rss>