<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Björn I. Dahlgren's personal page (Posts about SymPy)</title><link>http://bjodah.github.io/blog/</link><description></description><atom:link type="application/rss+xml" href="http://bjodah.github.io/blog/categories/sympy.xml" rel="self"></atom:link><language>en</language><lastBuildDate>Sun, 11 Jun 2017 21:55:48 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Status update week 2 GSoC</title><link>http://bjodah.github.io/blog/posts/gsoc-week2.html</link><dc:creator>Björn Dahlgren</dc:creator><description>&lt;div&gt;&lt;p&gt;I have spent the second week of Google Summer of Code on essentially two things:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Continued work on type awareness in the code printers (&lt;tt class="docutils literal"&gt;CCodePrinter&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;FCodePrinter&lt;/tt&gt;). The work is ongoing in &lt;a class="reference external" href="https://github.com/sympy/sympy/pull/12693"&gt;gh-12693&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Writing tutorial &lt;a class="reference external" href="https://github.com/sympy/scipy-2017-codegen-tutorial"&gt;code&lt;/a&gt; on code-generation in the form of jupyter notebooks for the
upcoming SciPy 2017 &lt;a class="reference external" href="https://scipy2017.scipy.org/ehome/220975/493418/"&gt;conference&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="precision-aware-code-printers"&gt;
&lt;h2&gt;Precision aware code printers&lt;/h2&gt;
&lt;p&gt;After my weekly mentor meeting, we decided to take another approach to
how we are going to represent &lt;tt class="docutils literal"&gt;Variable&lt;/tt&gt; instances in the
&lt;tt class="docutils literal"&gt;.codegen.ast&lt;/tt&gt; module. Previously I had proposed to use quite a
number of arguments (stored in &lt;tt class="docutils literal"&gt;.args&lt;/tt&gt; since it inherits
&lt;tt class="docutils literal"&gt;Basic&lt;/tt&gt;). Aaron suggested we might want to represent that underlying
information differently. After some discussion we came to the
conclusion that we could introduce a &lt;tt class="docutils literal"&gt;Attribute&lt;/tt&gt; class (inhereting
from &lt;tt class="docutils literal"&gt;Symbol&lt;/tt&gt;) to describe things such as value const-ness, and
pointer const-ness (those two are available as &lt;tt class="docutils literal"&gt;value_const&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;pointer_const&lt;/tt&gt;). Attributes will be stored in a &lt;tt class="docutils literal"&gt;FiniteSet&lt;/tt&gt;
(essentially SymPy version of &lt;tt class="docutils literal"&gt;set&lt;/tt&gt;) and the instances we provide as
"pre-made" in the &lt;tt class="docutils literal"&gt;.codegen.ast&lt;/tt&gt; module will be supported by the
printers by default. Here is some example code showing what the
current proposed API looks like (for C99):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; u = symbols('u', real=True)
&amp;gt;&amp;gt;&amp;gt; ptr = Pointer.deduced(u, {pointer_const, restrict})
&amp;gt;&amp;gt;&amp;gt; ccode(Declaration(ptr))
'double * const restrict u;'
&lt;/pre&gt;
&lt;p&gt;and for Fortran:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; vx = Variable(Symbol('x'), {value_const}, float32)
&amp;gt;&amp;gt;&amp;gt; fcode(Declaration(vx, 42))
'real(4), parameter :: x = 42'
&lt;/pre&gt;
&lt;p&gt;The C code printer can now also print code using different math functions depending
on the targeted precision (functions guaranteed to be present in the C99 stanard):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; ccode(x**3.7, standard='c99', precision=float32)
'powf(x, 3.7F)'
&amp;gt;&amp;gt;&amp;gt; ccode(exp(x/2), standard='c99', precision=float80)
'expl((1.0L/2.0L)*x)'
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="tutorial-material-for-code-generation"&gt;
&lt;h2&gt;Tutorial material for code generation&lt;/h2&gt;
&lt;p&gt;Aaron, Jason and I have been discussing what examples to use for the
tutorial on code generation with SymPy. Right now we are aiming to use
quite a few examples from chemistry actually, and more specifically
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Chemical_kinetics"&gt;chemical kinetics&lt;/a&gt;. This is the
precise application which got me started using SymPy for
code-generation, so it lies close to my heart (I do extensive modeling
of chemical kinetics in my PhD studies).&lt;/p&gt;
&lt;p&gt;Working on the tutorial material has already been really helpful for
getting insight in development needs for the exisiting classes and
functions used for code-generation. I was hoping to use &lt;tt class="docutils literal"&gt;autowrap&lt;/tt&gt;
from the &lt;tt class="docutils literal"&gt;.utilities&lt;/tt&gt; module. Unfortunately I found that it was not
flexible enough to be useful for integration of systems of ODEs (where
we need to evaluate a vector-valued function taking a vector as
input). I did attempt to subclass the &lt;tt class="docutils literal"&gt;CodeWrapper&lt;/tt&gt; class to allow
me to do this. But personally I found those classes to be quite hard to
extend (much unlike the printers which I've often found to be
intuitive).&lt;/p&gt;
&lt;p&gt;My current plan for the chemical kinetics case is to first solve it
using &lt;tt class="docutils literal"&gt;sympy.lambdify&lt;/tt&gt;.  That allows for quick prototyping, and
unless one has very high demands with respect to performance, it is
usually good enough.&lt;/p&gt;
&lt;p&gt;The next step is to generate a native callback (it was here I was
hoping to use &lt;tt class="docutils literal"&gt;autowrap&lt;/tt&gt; with the Cython backend). The current
approach is to write the expressions as Cython code using a template.
Cython conveniently follows Python syntax, and hence the string
printer can be used for the code generation. Doing this speeds up the
integration considerably. At this point the bottleneck is going back and
forth through the Python layer.&lt;/p&gt;
&lt;p&gt;So in order to speed up the integration further, we need to bypass
Python during integration (and let the solver call the user
provided callbacks without going through the interpreter). I did
this by providing a C-code template which relies on &lt;tt class="docutils literal"&gt;CVode&lt;/tt&gt; from the
&lt;a class="reference external" href="https://computation.llnl.gov/projects/sundials"&gt;Sundials&lt;/a&gt; suite of
non-linear solvers. It is a well established solver and is already
available for Linux, Mac &amp;amp; Windows under conda from the
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;conda-forge&lt;/span&gt;&lt;/tt&gt; channel. I then provide a thin Cython wrapper, calling
into the C-function, which:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;sets up the CVode solver&lt;/li&gt;
&lt;li&gt;runs the integration&lt;/li&gt;
&lt;li&gt;records some statistics&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Using native code does come at a cost. One of the strengths of Python
is that it is cross-platform. It (usually) does not matter if your
Python application runs on Linux, OSX or Windows (or any other
supported operating system). However, since we are doing
code-generation, we are relying on compilers provided by the
respective platform. Since we want to support both Python 2 &amp;amp; Python 3
on said three platforms, there are quite a few combinations to cover.
That meant quite a few surprises (I now know for example that MS
Visual C++ 2008 does not support C99), but thanks to the kind &lt;a class="reference external" href="https://github.com/sympy/scipy-2017-codegen-tutorial/issues/2#issuecomment-307538308"&gt;help&lt;/a&gt; of
&lt;a class="reference external" href="https://github.com/isuruf"&gt;Isuru Fernando&lt;/a&gt; I think I will manage to
have all platform/version combinations working during next week.&lt;/p&gt;
&lt;p&gt;Also planned for next week:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use &lt;tt class="docutils literal"&gt;numba&lt;/tt&gt; together with &lt;tt class="docutils literal"&gt;lambdify&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;tt class="docutils literal"&gt;Lambdify&lt;/tt&gt; from &lt;a class="reference external" href="https://github.com/symengine"&gt;SymEngine&lt;/a&gt;
(preferably with the LLVM backend).&lt;/li&gt;
&lt;li&gt;Make the notebooks more tutorial like (right now they are more of a
show-case).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and of course: continued work on the code printers. That's all for now
feel free to get in touch with any feedback or questions.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>Python</category><category>SymPy</category><guid>http://bjodah.github.io/blog/posts/gsoc-week2.html</guid><pubDate>Sun, 11 Jun 2017 21:37:00 GMT</pubDate></item><item><title>A summer of code and mathematics</title><link>http://bjodah.github.io/blog/posts/gsoc-week1.html</link><dc:creator>Björn Dahlgren</dc:creator><description>&lt;div&gt;&lt;p&gt;Google are generously funding work on selected &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Open-source_software"&gt;open source&lt;/a&gt; projects each
year through the &lt;a class="reference external" href="https://summerofcode.withgoogle.com/"&gt;Google Summer of Code&lt;/a&gt; project. The project allows
under- and post-graduate students around the world to apply to
mentoring organizations for a scholarship to work on a project during
the summer. This spring I made the leap, I wrote a &lt;a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2017-Application-Bj%C3%B6rn-Dahlgren:-Improved-code-generation-facilities"&gt;proposal&lt;/a&gt; which
got accepted, and I am now working full time for the duration of this
summer on one of these projects. In this blog post I'll give some
background and tell you about the first project week.&lt;/p&gt;
&lt;div class="section" id="background"&gt;
&lt;h2&gt;Background&lt;/h2&gt;
&lt;p&gt;Since a few years I've been contributing code to the open-source project
&lt;a class="reference external" href="http://www.sympy.org"&gt;SymPy&lt;/a&gt;. SymPy is a so-called "computer algebra system",
which lets you manipulate mathematical expressions symbolically. I've used this
software package extensively in my own doctoral studies and it has been really useful.&lt;/p&gt;
&lt;p&gt;My research involves formulating mathematical models to: rationalize experimental observations,
fit parameters or aid in design of experiments. Traditionally one sits down and derive equations,
often using pen &amp;amp; paper, then one writes computer code which implements said model, and finally
one writes a paper with the same formulas as LaTeX code (or something similar).
Note how this procedure involves writing the same equations essentially three times,
during derivation, coding and finally the article.&lt;/p&gt;
&lt;p&gt;By using SymPy I can, from a single source:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Do the derivations (fewer hard-to-find mistakes)&lt;/li&gt;
&lt;li&gt;Generate the numerical code (a blazing fast computer program)&lt;/li&gt;
&lt;li&gt;Output LaTeX formatted equations (pretty formulas for the report)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A very attractive side-effect of this is that one truly get reproducible research
(reproducibility is one of the pillars in science). Every step of the process is
self-documented, and because SymPy is free software: &lt;em&gt;anyone&lt;/em&gt; can redo them. I
can't stress enough how big this truly is. It is also the main
motivation why I haven't used proprietary software in place of SymPy,
even though that software may be considerably more feature complete
than SymPy, any code I wrote for it would be inaccessible to people
without a license (possibly even including myself if I leave academia).&lt;/p&gt;
&lt;p&gt;For this work-flow to work in practice the capabilities of the computer algebra system
need to be quite extensive, and it is here my current project with SymPy comes in.
I have had several ideas on how to improve capability number two
listed above: generating the numerical code, and now I get the chance
to realize some of them and work with the community to improve SymPy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="first-week"&gt;
&lt;h2&gt;First week&lt;/h2&gt;
&lt;p&gt;The majority of the first week has been spent on introducing type-awareness into
the code-printers. SymPy has printer-classes which specialize printing of e.g.
strings, C code, Fortran code etc. Up to now there has been no way to indicate
what precision the generated code should be for. The default floating point type
in python is for example "double precision" (i.e. 64-bit binary IEEE 754 floating
point). This is also the default precision targeted by the code
printers.&lt;/p&gt;
&lt;p&gt;However, there are occasions where one want to use another
precision. For example, consumer class graphics cards which are
ubiquitous often have excellent single precision performance, but are
intentionally capped with respect to double precision arithmetic (due
to marketing reasons). At other times, one want just a bit of extra
precision and extended precision (80-bit floating point, usually the
data type of C's &lt;tt class="docutils literal"&gt;long double&lt;/tt&gt;) is just what's needed to compute
some values with the required precision. In C, the &lt;a class="reference external" href="http://en.cppreference.com/w/c/numeric/math"&gt;corresponding math functions&lt;/a&gt; are standardized since
C99.&lt;/p&gt;
&lt;p&gt;I have started the work to enable the code printers to print this in a
&lt;a class="reference external" href="https://github.com/sympy/sympy/pull/12693"&gt;pull-request&lt;/a&gt; to the
SymPy source repository. I have also started experimenting with a
class representing arrays. Arrays&lt;/p&gt;
&lt;p&gt;The first weekly meeting with &lt;a class="reference external" href="http://asmeurer.com"&gt;Aaron Meurer&lt;/a&gt; went well and we also briefly
discussed how to reach out to the SymPy community for wishes on what
code-generation functions to provide, I've set up a wiki-page for it
under the SymPy projects wiki:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/sympy/sympy/wiki/codegen-gsoc17"&gt;https://github.com/sympy/sympy/wiki/codegen-gsoc17&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I'll be sending out an email to the &lt;a class="reference external" href="https://groups.google.com/forum/#!forum/sympy"&gt;mailing list for SymPy&lt;/a&gt; asking for feedback.&lt;/p&gt;
&lt;p&gt;We also discussed the upcoming SciPy 2017 conference where Aaron
Meurer and &lt;a class="reference external" href="http://www.moorepants.info/"&gt;Jason Moore&lt;/a&gt; will be giving
a tutorial on code-generation with SymPy. They've asked me to join
forces with them and I've happily accepted that offer and am looking
forward to working on the tutorial material and teaching fellow
developers and researchers in the scientific python community about
how to leverage SymPy for code generation.&lt;/p&gt;
&lt;p&gt;Next blog post will most likely be a bit more technical, but I thought
it was important to give some background on what motivates this effort
and what the goal is.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>Python</category><category>SymPy</category><guid>http://bjodah.github.io/blog/posts/gsoc-week1.html</guid><pubDate>Sat, 03 Jun 2017 13:10:00 GMT</pubDate></item></channel></rss>